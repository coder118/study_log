
# 문제 정의
크로아티아 알파벳	변경
č	c=
ć	c-
dž	dz=
đ	d-
lj	lj
nj	nj
š	s=
ž	z=

알파벳과 -,=이 포함된 문자를 입력받는다. 
단, 정해진 규칙이 있다. 특정 영문자의 조합이 하나의 크로아티어 언어로 바뀌게 된다.
위 표에 없을 경우 그냥 알파벳으로 카운트한다.

여기서 총 크로아티아의 언어의 개수를 구해라.

# 처음 든 생각

1.HashMap을 사용해서 크로아티아어를 문자열에 대응되게 넣는다. 되지 않을까 생각한다.


2.문자열을 쪼개야 한다. 하지만 그냥 나누면 안된다. 왜? 여러개의 영문자가 하나의 크로아티아 언어가 되기때문이다. 그럼 앞에 어떤 값이 올지 모르는데 어떻게 문자열을 쪼개지? 
=> 입력받은 문자열에 해쉬맵의 키값이 있는 지 확인.


3.확인 된 값을 지우면 남은 알파벳 값의 개수를 구한다.





# 문제 발생

해쉬맵을 만들더라도 어떻게 입력 받은 문자열을 쪼갤 수 있는지 모르겠다. 
해결해야 할 부분은 입력받은 문자열에서 어떻게 크로아티아 언어를 인식할 수 있는지이다. 

반복문을 사용해서 문자를 조합해볼까? 조합되지 않으면 그냥 알파벳인것이고 조합되서 만약 그 값이 해쉬키 값에 있으면 1을 추가하면 될 것 같다.

배열의 split을 사용하면 구문이 쪼개져서 리스트로 만들어질때 그때 size을 계산하면 개수가 나올 것 같은데 이건 파이썬이다. 



### 내가 처음 한 생각

    for (int i = 0; i < input.length(); i++) {
                String a = String.valueOf(input.charAt(i));
                String b = String.valueOf(input.charAt(i+1));
                String combi = a+b;//문자를 쪼개서 조합을 만듦


        if(combi.equals("dz") && String.valueOf(input.charAt(i+2)).equals("=")){//크로아티아 문자중에 3글자문자 처리.
            combi+=String.valueOf(input.charAt(i+2));
            individual_alpa.add(combi);
            i=i+2;

        }
        else if(c_alpabet.containsKey(combi)) { //크로아티아 문자처리
            individual_alpa.add(combi);
            i++;

        }else{//단일 알파벳 처리
            individual_alpa.add(a);
        }

    }

문자열을 쪼개서 조합하는 코드이다. 조합한 combi값이 hashmap에 존재하면 list에 넣어준다.
여기서 list는 단일 알파벳과 크로아티아어를 넣어주기 위한 공간이다. 
하지만 여기서 생긴 문제점은 마지막에 단일 알파벳 2개가 나올 경우 전부다 카운팅되기 전에 반복문이 종료된다는 문제가 있었다.


# 해결
위에서 고민했던 반복문을 해결할 수 있었다. 

하지만, ai의 도움을 받았다. 


    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
    HashMap<String, Integer> c_alpabet = new HashMap<>();

    String input = bf.readLine();

    String[] alpabet = {"c=", "c-", "dz=", "d-", "lj", "nj", "s=", "z="};

    List<String> individual_alpa = new ArrayList<>();

    int count =0;
    for (String str : alpabet) {
        c_alpabet.put(str, 1);
    }

위의 코드는 처음 한 생각에서 1번을 구현했다.
 

    for (int i = 0; i < input.length(); i++) {
        String a = String.valueOf(input.charAt(i));

        // 다음 문자가 있는지 확인
        if (i < input.length() - 1) {
            String b = String.valueOf(input.charAt(i + 1));
            String combi = a + b;

            // "dz=" 처리
            if (combi.equals("dz") && (i + 2 < input.length()) && String.valueOf(input.charAt(i + 2)).equals("=")) {
                combi += "="; // "dz=" 추가
                individual_alpa.add(combi);
                i += 2; // 두 글자 처리했으므로 인덱스 증가
                continue; // 다음 루프 진행
            }

            // 다른 조합 확인
            if (c_alpabet.containsKey(combi)) {
                individual_alpa.add(combi);
                i++; // 두 글자 처리했으므로 인덱스 증가
                continue; // 다음 루프 진행
            }
        }

        // 마지막 문자가 단일 문자일 경우 추가
        individual_alpa.add(a);
    }


이 구간을 분리해줌으로써 

    if (i < input.length() - 1)

반복문이 종료되는 것을 막았다. 지금까지 **반복문에서만** 뒤에 문자가 있는지 없는지를 처리하고 있었다. 이걸 반복문에서 떼어 조건문을 만들어줌으로써 문제를 해결했다.


# 개선점

처음 한 생각의 접근 방식이 아예 다르다. 조금 더 구체적으로 짜는 노력이 필요할 것 같다. 

이렇게 반복문으로 조합을 만들어내지 않고도 푸는 방법이 있을 것 같다. 

[내가 처음했던 생각에 적은 내용, 1번째 코드(contain,replace)](https://hayeon17kim.github.io/posts/baekjoon2941/)

# 배운점

너무 화려하고 복잡한것을 사용하려 하지 않아도 간단히 해결할 수 있다. 너무 문제를 부풀려 생각함.