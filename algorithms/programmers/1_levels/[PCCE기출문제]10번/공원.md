import java.util.*;

class Solution {
    public int solution(int[] mats, String[][] park) {
        int answer = 0;
        
        
        //방법
        //어떻게 하면 -1의 정사각형을 구할 수 있을까? 
        
        //행을 기준으로 반복을 돌려서 가장 긴 -1의 행 좌표를 찾는다.
        int checking_row =-1;
        checking_row=longest_line_row(park,checking_row);
        
        // 가장 긴 열의 좌표를 찾는다. 위의 행과 교차되는 지점의 좌표를 구한다.
        //단, 가장 긴 열이 되어야 한다.(가장 긴 -1을 가지고 있어야 한다.)
        int checking_col =-1;
        checking_col = longest_line_col(park,checking_col);
        
        //위에서 구한 교차점에서 위에서 말한 것처럼([2+mat-1]) 가장 큰 mat정수부터 더한다.
        //차례로 내려가며 mat사이즈를 줄여나간다.
        Arrays.sort(mats);

        for (int s = mats.length - 1; s >= 0; s--) {
            try{
                if(park[checking_row][checking_col].equals("-1") && 
                   park[checking_row+mats[s]-1][checking_col].equals("-1")&& 
                   park[checking_row][checking_col+mats[s]-1].equals("-1") && 
                   park[checking_row+mats[s]-1][checking_col+mats[s]-1].equals("-1")){
                    answer = mats[s];
                    break;
                }
            }catch(IndexOutOfBoundsException e){
                continue;
            }

        }
        return answer;
    }
    
    private int longest_line_row(String[][] park,int checking_row){
        int row_length =0;
        int row_length_max =0;
        //행을 기준으로 반복을 돌려서 가장 긴 -1의 행 좌표를 찾는다.
        for(int row =0; row<park.length; row++){
            row_length =0;
            for(int col =0; col<park[row].length-1; col++){
                //연속되는 -1이 가장 긴 행은 몇번 째인가?
                //연속되는 것을 컴퓨터가 알게 하려면 앞에 값과 뒤의 값이 일치하는지 봐야 한다.(버블정렬.?)
                if(park[row][col].equals("-1") && park[row][col+1].equals("-1")){
                    if (row_length == 0) { // 처음에만 2를 더함
                        row_length += 2;    
                    } else {
                        row_length += 1; // 연속된 경우
                    }

                    if (row_length > row_length_max) {
                        row_length_max = row_length;
                        checking_row = row; // 가장 긴 row의 좌표 저장
                    }
                    
                }
            }
        }
        
        return checking_row;
    }
    
    private int longest_line_col(String[][] park,int checking_col){
        int col_length = 0;
        int col_length_max = 0;
        //행을 기준으로 반복을 돌려서 가장 긴 -1의 열 좌표를 찾는다.
        for(int col =0; col<park[0].length; col++){
            col_length =0;
            for(int row =0; row<park.length-1; row++){
                
                if(park[row][col].equals("-1") && park[row + 1][col].equals("-1")){
                    if (col_length == 0) { // 처음에만 2를 더함
                        col_length += 2;    
                    } else {
                        col_length += 1; // 연속된 경우
                    }

                    if (col_length > col_length_max) {
                        col_length_max = col_length;
                        checking_col = col; // 가장 긴 열의 좌표 저장
                    }
                    
                }
            }
        }
        
        return checking_col;
    }
    
    
}


# 문제 정의
mats = 돗자리들의 한변의 길이 정사각형의 형태 배열
park = 현재 공원의 자리 배치도., 2차원 배열
park에 사람이 있으면 알바벳 한글자를 가진다. 없다면 -1 문자열을 가진다. 

주어진 mats에서 park에 가장 넓게 깔 수 있는 사이즈의 mats를 구해라.  
깔수 없다면 -1을 반환한다.

문제 정리 => 알바벳이 있는 자리는 사용 불가능. -1 자리만 사용 가능.
만약, mats를 깔았을때 한 곳이라도 영어가 있다면 까는 것이 불가능하다.

# 처음 생각한 방법

1. 어떻게 하면 이곳에 돗자리를 깐다고 인식하게 할 수 있을까?
=> 배열의 행과 열 부분에 mats정수의 값을 더해서 돗자리를 깔았다고 인식 시킨다.
park[2+mats-1][2+mats-1] 아 좌표값과 같다.
범위를 전부 정해서 색칠해주는 것이 아니라, 좌표를 설정해준다. 
park[2][2] park[2][2+mats-1](오른쪽으로 mats길이만큼) park[2+mats-1][2] (아래로) 
park[2+mats-1][2+mats-1](대각선으로 )
어떤 식으로 인식시키면 될지 알겠다. 

2.위에서 구한 좌표값에 만약 알바벳이 있으면 깔 수 없다.(조건) 
근데, 이 좌표를 하나하나 이동해가면서 깔 수 있는 자리를 찾는 것보다.
-1로 만들 수 있는 가장 큰 정사각형의 좌표를 구하면 깔수 잇는 돗자리 mats가 나올 것 같다.

3. -1의 정사각형의 크기가 mats내부에 있으면 그 값이 답이 되고. 만약 없더라도, 그 값보다 작은 mats
정수가 있으면 그것이 답이된다. 
mats의 정수값들이 -1 정사각형 값보다 크다면 -1을 반환해야한다. 


# 문제 발생

테스트 케이스는 성공했다. 하지만 내 코드는 테스트 케이스에만 맞는 경우를 만들어버렸다.
다른 테스트 케이스는 실패했다. 



# 피드백 

지금 보니까 처음 생각한 부분에서 놓친게 있다. 

1번에서 각 자리의 꼭지점만 찾으면 네모가 들어올 틈이 없다고 생각했는데 생각해보니 작은 돗자리가 있을 경우를 생각하지 못했다.
2번에서 하나하나 매트를 까는 방법이 너무 오래걸려서 잘못 된 것 같다고 말했는데 그게 정답인 것 같다. 

[정답자 풀이1](https://velog.io/@dnjswns98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-PCCE-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-10%EB%B2%88-%EA%B3%B5%EC%9B%90.java)

[정답자 풀이2](https://loseminho.tistory.com/31)

# 배운점 및 오답

내 문제 풀이 과정이 너무 추상적이다. 

첫번째 정답자의 문제 풀이 과정
1. 돗자리를 필수 있는 지 검사하기위해 내림차순 정렬.
2. 각 돗자리 크기에 맞게 배열을 탐색한다.

3. 첫 포문 2개로 공원의 모든 인덱스를 탐색함. 
4. 3번에서 포문을 돌다가 빈공간(즉, -1)을 찾으면 그 공간에서 시작해 돗자리 크기만큼 모두 빈공간인지 탐색해야 한다. @ 중요한 점. 돗자리를 깔았을때 공원의 영역 바깥으로 나가는지 안나가는지 확인해줘야 함.

-중간에 사람있으면 루프를 중단하기도 한다. 

그리드 완전탐색으로 푸는 문제이다. 

[그리디 알고리즘 참고 자료.](https://adjh54.tistory.com/212)
