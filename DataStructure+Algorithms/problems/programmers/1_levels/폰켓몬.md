# 폰켓몬

    int answer = 0;
        
    //nums 내부에 N마리 포켓몬 (배열,인덱스,초기화 값 0) 
    //nums는 항상 짝수이다.
    //내가 가져갈 수 있는 건 N/2개 ,배열의 절반
    
    //목적= 가장 많은 종류의 포켓몬을 선택하고 그 종류가 몇마리인지 반환해라.
    //총 선택할 수있는 최대의 개수는 N/2다.
    //그 최대 개수에서 가질 수 있는 조합을 생각하자.
    //1. 겹치는 값이 아예 없고 N/2개가 될때 최대값
    //2. 배열을 찾아보며 각각의 값을 map에 넣었지만 N/2의 개수를 채우지 못했을 경우. 그 맵의 개수가 최대값
    
    Map<Integer,Integer> bucket = new HashMap<>();
    
    int mine= nums.length/2;
    
    for(int i =0; i<nums.length; i++){
        if(i==0){//처음 값은 무조건 채운다.
            bucket.put(nums[i],1);
            continue;
        }
        if(bucket.size()>=mine){
            break; //내가 가질 수 있는 개수가 가득 찼을 경우
        }
            
        if(bucket.getOrDefault(nums[i],0)==1){
            continue; // 같은 값이 있으면 채우지 않는다.
        }
        
        bucket.put(nums[i],1);
        
        
    }
    
    answer = bucket.size();
    return answer;


### 생각해볼 내용

맵이 아니라 리스트로 풀었어도 충분했을 것 같다. 
