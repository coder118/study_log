
# 나의 사고 과정

1. a와 b를 동시에 나눌 수 있는 값으로 더이상 나누어지 않을 때까지 나눈다.
2. 나누어지는 값을 반복을 통해 찾는다.

3. b를 소인수분해(2로 계속 나눈다) 
4. 나오는 값 중에 2,5만 존재한다면 유한소수=1반환
5. 2,5 이외의 값이 있다면 무한 소수=2반환


## 다른 사람의 사고 과정

1. 최대공약수를 구한다.
2. 그 최대 공약수로 b값을 나누면 기약분수가 된다.
3. b값을 2와 5로 나누는데 계속 반복한다. 만약 하나라도 2와 5로 나누어지지 않으면 무한 소수이다.

## 왜 다른가?

최대공약수와 기약분수가 만들어지는 과정을 생각하지 못했다.
최대 공약수를 나누었을때 출력되는 값은 기약분수 값.

    int max = 0; 
    for(int i =1; i<=a; i++){
        if(a%i==0 && b%i==0){
            max = i; // 이것이 최대 공약수
        }
    }

    b/=max;
    
    while(b>1){
        
        if(b%2==0){
            b/=2;
        }
        else if(b%5==0){
            b/=5;
        }
        else{
            2와 5로 나누어지지않으면 무한 소수이다.
        }
    }
    
## 다른 방식

최대 공약수를 구하기 위해 반복문을 돌리는 대신 재귀함수로도 구현이 가능.

    main함수
    {...
    b /= gcd(a, b);
    ..
    }
    private int gcd(int a, int b) {
            if (b == 0) {
                return a;
            }
            return gcd(b, a % b);
    }