# 나의 사고 과정

> 해당 문제의 조건을 정리한다

- 문자열 s가 주어진다.
- s의 길이는 1000이하이다.=> O(N^2)이상의 시간 복잡도를 가질 수 있다.
- 제일 앞부터 문자열이 나누어져야 한다.

> 알고리즘 풀이

1. 문자열을 substring해서 겹치는 문자열을 찾을 수 있는 기준 문자열을 만든다.
2. 기준 문자열이 뒤에 있는 문자열을 확인하며 equals한 값이 있는지 확인한다.
3. 동일한 문자열이 있을 경우 count를 증가시킨다. 그리고 그 다음 문자열을 계속해서 탐색한다.
4. 동일한 문자열이 아닐 경우 
    - count값이 1 이상이라면 기준 문자열 앞에 숫자를 적어서 stringbuilder에 append 해준다.
    - count값을 초기화 한다.
    - 기존의 기준 문자열을 새롭게 바꿔준다.

5. 문자열의 길이가 가장 짧은 것을 answer에 담는다.

> 내 풀이

1번에서 기준 문자열을 찾는 과정을 그림으로 나타낸다. 

![간단한 풀이 과정](image.png)

빨간색으로 친 동그라미가 기준이 되는 문자열들의 규칙이다. 
앞은 0으로 그대로 뒤에 값이 변한다.


    int answer = 0;
    int len = s.length();
    int count=1;
    
    int before = 1001;
    
    for(int i = 1; i<len/2; i++){
        String base = s.substring(0,i);
        int base_len = base.length();
        StringBuilder compressor = new StringBuilder();
        for(int search = i+base_len; search<len; search+=i ){
            int endIdx = Math.min(search,len);
            String next_str = s.substring(search,endIdx);

            if(base.equals(next_str)){
                count++;
            }else{
                if(count>=2){
                    compressor.append(count+base);    
                }
                count =1;
                base = next_str;
                
            }

        }
        answer = Math.min(before,compressor.length());
        before = compressor.length();
    }
        
틀림

# 다른 사람의 문제 해결과정

1. 기준 문자열을 만든다.
2. 기준 문자열이 뒤에 있는 문자열을 확인하며 equals한 값이 있는지 확인한다.
3. 해결과정은 나와 동일함. 
4. 나와 동일
5. 나와 동일

문제 해결 과정의 문제가 아니라 이 과정을 코드로 구현하는데 문제가 있다는 것.

그중 2번 부분에서 실수했다.
- for(int i = 1; i< len/2; i++) 
이 부분에서 =을 붙어줘야 한다.  
- search< len을 len의 범위를 포함해야 한다. = 을 붙어줘야 한다.


---
    int base_len = base.length();
    StringBuilder compressor = new StringBuilder();
    for(int search = i+base_len; search< len; search+=i ){
    
        int endIdx = Math.min(search,len);
    }

search값을 i+base_len을 할 필요 없이를 해주면된다.

    Math.min(search+i,len);


# 정리

반복되는 범위를 신경쓰는 것이 중요하다. 
인덱스를 나누는 과정이 아직 취약한 것 같다. 이 부분에 대한 학습이 더 필요하다.



[참고 사이트](https://velog.io/@ckr3453/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95-Java)