# 나의 사고 과정

> 조건 생각해보기

s의 길이가 1000 이하=> 시간복잡도가 O(N^3)까지 가능하다.

> 알고리즘 풀이

1. 왼쪽으로 문자열이 빠져서 오른쪽 맨끝에 붙으며 회전해야 한다.s.length() 만큼
    - 문자열을 char로 쪼개서 큐에 넣고 poll하고 offer하는 방식이면 구현 가능

2. 회전시킨 값이 올바른 괄호 형태를 가지고 있는지 확인한다.
3. 각 괄호별 스택을 만들어서 괄호가 열리는 값을 스택에 push해주고 닫히는 괄호가 나오면 pop해준다.
    - 만약, 닫히는 괄호가 실행될때 스택이 비어있으면 닫히는 괄호가 먼저시작하면 올바른 괄호 형태가 나올 수 없기 때문에 종료한다. 


> 코드 구현

    import java.util.*;
    class Solution {
        public int solution(String s) {
        
            ArrayDeque<Character> rotation_str = new ArrayDeque<>();
            int len = s.length();
            for(int i =0; i< len; i++){
                rotation_str.offer(s.charAt(i));
            }
            
            int count =0;
            for(int i =0; i<len; i++){
                //rotation_str를 문자열의 길이만큼 회전시키는 반복문
                ArrayDeque<Character> temp = new ArrayDeque<>(rotation_str);
                ArrayDeque<Character> stack_mid = new ArrayDeque<>();
                ArrayDeque<Character> stack_small = new ArrayDeque<>();
                ArrayDeque<Character> stack_big = new ArrayDeque<>();

                boolean check = false;
                for(int i2 =0; i2<len; i2++){
                    //rotation_str의 괄호 값이 타당한지 확인하는 반복문
                    
                    char value = temp.poll();
                    if(value =='('){
                        stack_small.push(value);
                        continue; //열린 괄호가 들어가면 그 다음 문자를 탐색한다.
                    }else if(value=='['){
                        stack_mid.push(value);
                        continue;
                    }else if(value=='{'){
                        stack_big.push(value);
                        continue;
                    }
                    
                    if(value==')'){
                        if(!stack_small.isEmpty()){
                            stack_small.pop();
                        }else{
                            check =true;// 올바른 괄호가 아니면 카운트 안함
                            break; //하나라도 괄호가 완전하지 않으면 반복을 종료
                        }
                    }else if(value==']'){
                        if(!stack_mid.isEmpty()){
                            stack_mid.pop();
                        }else{
                            check =true;
                            break; //하나라도 괄호가 완전하지 않으면 반복을 종료
                        }
                    }else if(value=='}'){
                        if(!stack_big.isEmpty()){
                            stack_big.pop();
                        }else{
                            check =true;
                            break; //하나라도 괄호가 완전하지 않으면 반복을 종료
                        }
                    }
                    
                }
                if(!check){
                    //올바른 괄호 문자열의 수를 카운팅한다.
                    count+=1;
                }
                
                //len만큼 왼쪽으로 문자를 회전시킨다. 
                rotation_str.offer(rotation_str.poll());
                
            }
            
            return count;
        }
    }

테스트케이스는 전부 통과했다. 
딱 2개의 경우에서 실패했다. 

# 문제 해결

ai의 도움을 받아 내부 로직의 가독성을 높이고 실패한 부분을 해결했다.

    for (int i = 0; i < len; i++) {
        ArrayDeque<Character> temp = new ArrayDeque<>(rotation_str);
        ArrayDeque<Character> stack = new ArrayDeque<>();
        boolean isValid = true;

        for (int i2 = 0; i2 < len; i2++) {
            char value = temp.poll();

            if (value == '(' || value == '[' || value == '{') {
                stack.push(value);
            } else if (value == ')' || value == ']' || value == '}') {
                if (stack.isEmpty()) {
                    isValid = false;
                    break;
                }

                char top = stack.pop();
                if ((value == ')' && top != '(') ||
                    (value == ']' && top != '[') ||
                    (value == '}' && top != '{')) {
                    isValid = false;
                    break;
                }
            }
        }

        // 모든 문자를 처리한 후 스택이 비어 있어야 유효한 괄호
        if (isValid && stack.isEmpty()) {
            count++;
        }

        // len만큼 왼쪽으로 문자를 회전시킨다. 
        rotation_str.offer(rotation_str.poll());
    }

스택을 각자 하나씩 사용해줄 필요없이 간결하게 표현됨

1. 열린 괄호가 나오면 push한다.
2. 닫힌 괄호가 나왔을때 열린괄호가 한번도 열리지 않았을 경우
3. 닫힌 괄호가 나왔을때 열린괄호가 stack에 존재하는 경우
    - value가 "(" 닫힌 괄호가 나왔을떄 stack에 가장 상위에 존재하는 값이 ")"이 아니라면 유효하지 않은 괄호 쌍이라는 조건이다.


# 배운점 및 고칠점

나는 3번의 경우를 생각하지 못했다. 문제가 길고 복잡한데 거기서 어떤 조건이 필요한지 위처럼 순차적으로 정리되어야 하는데 정리가 안된다.

무작정 스택을 선언해서 메모리를 많이 사용하는 것은 좋지 않다.

조건문을 잘 활용하지 못한다. and,or연산을 아직 헷갈려하는 것 같다. 