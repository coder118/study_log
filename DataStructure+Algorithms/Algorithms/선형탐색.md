# 목차

1. [기본적인 선형 탐색 방법들](#어떤-방법들이-있을까)
2. [버블 정렬](#bubble-sort버블-정렬)
3. [삽입 정렬](#insertion-sort삽입-정렬)
4. [선택 정렬](#selection-sort선택-정렬)
5. [퀵 정렬](#quick-sort퀵-정렬)
6. [병합 정렬](#merge-sort병합-정렬)

----
[참고 자료 목록](#참고-자료)

----
### 배열과 리스트는 선형적으로 저장되어있다. 

선형적인 내부에서 어떻게 효율적으로 데이터를 찾을지 연구한 방법이 선형 탐색이다. 


### 어떤 방법들이 있을까?

1. 하나하나씩 값을 다 찾아보는 방법. O(n)

2. **이진 탐색**(=데이터를 찾아야 하는 범위를 축소 시켜서 탐색하는 방법.) O(logn)

중요한 조건은 정렬되어있는 상태여야 한다.

![순차 탐색과 이진 탐색 이미지.](image.jpg)



    //n은 내가 찾고자 하는 숫자.

    //left,right,mid 전부 인덱스 위치다.
    int answer
    int left = 0; 
    int right = arr.length-1;
    int mid;

    while(left<= right){
        mid = (left+right)/2;//중간값의 인덱스를 찾는다.
        
        // 찾는 값이 중간에 있는 값보다 크다면 오른쪽에 있다는 것이니 왼쪽 인덱스가 이동.
        if(arr[mid] < n ) left= mid +1;

    //찾는 값이 중간에 있는 값보다 작다면 왼쪽에 있다는 것이니 오른쪽 인덱스가 이동.
        else if(arr[mid ] > n) right = mid -1;

        else answer = mid;
    }

[**목차로**](#목차)



# 추가적인 정렬 방법들

![정렬 알고리즘들의 시간 복잡도](/DataStructure+Algorithms/Algorithms/algorithm_images/sort-time-complexity.png)

------
### bubble sort(버블 정렬)
=> 크기를 비교해서 작은 것을 왼쪽에 둔다.

O(n^2)의 복잡도를 가진다. 

![버블 정렬 이미지](/DataStructure+Algorithms/Algorithms/algorithm_images/bubble-sort.png)


[**목차로**](#목차)

-----
### selection sort(선택 정렬)

=> 첫 번째 자료를 두번째 자료부터 마지막 자료까지 차례로 비교해 가장 작은 값을 찾아 첫번째 값에 놓고, 두번째 값도 동일한 과정을 거친다. 

O(n^2)의 복잡도를 가진다. 


![선택 정렬이미지](/DataStructure+Algorithms/Algorithms/algorithm_images/selection-sort.png)


[**목차로**](#목차)


-------
### insertion sort(삽입 정렬)

=> 두번째 자료부터 시작해, 앞(왼쪽)의 자료들과 비교해서 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입해 정렬하는 알고리즘이다.

즉, 두번째 자료는 1번쨰 자료, 3번 자료는 1,2번 자료, 4번은 1,2,3자료를 탐색하는 것.

**가장 처음 key값은 2번쨰 자료부터 시작한다.**

시간복잡도는 best와worst가 다르다.

![삽입정렬 이미지](/DataStructure+Algorithms/Algorithms/algorithm_images/insertion-sort.png)

[**목차로**](#목차)

-----

### quick sort(퀵 정렬)

- 퀵 정렬 단계

1. 분할(divide) : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.

2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.

3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.

![퀵 정렬 전체적 이미지](/DataStructure+Algorithms/Algorithms/algorithm_images/quick-sort.png)


**- 퀵 정렬 알고리즘 예시**

1. 피벗 값을 입력 리스트의 첫 번째 데이터로 하자. (다른 임의의 값이어도 상관없다.)
2. 2개의 인덱스 변수(low, high)를 이용해서 리스트를 두 개의 부분 리스트로 나눈다.
3. 1회전: 피벗이 5인 경우,
    1. low는 왼쪽에서 오른쪽으로 탐색해가다가 피벗보다 큰 데이터(8)을 찾으면 멈춘다.
    2. high는 오른쪽에서 왼쪽으로 탐색해가다가 피벗보다 작은 데이터(2)를 찾으면 멈춘다.
    3. low와 high가 가리키는 두 데이터를 서로 교환한다.
    4. 이 탐색-교환 과정은 low와 high가 엇갈릴 때까지 반복한다.

4. 2회전: 피벗(1회전의 왼쪽 부분리스트의 첫 번째 데이터)이 1인 경우,
위와 동일한 방법으로 반복한다.
5. 3회전: 피벗(1회전의 오른쪽 부분리스트의 첫 번째 데이터)이 9인 경우,
위와 동일한 방법으로 반복한다.

![퀵 정렬 알고리즘 이미지](/DataStructure+Algorithms/Algorithms/algorithm_images/quick-sort2.png)



    import java.io.*;
    import java.util.*;
    public class Main {
    static int number = 10;  //데이터의 개수
    static int[] arr = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};  //정렬할 배열

    public static void main(String[] args) throws IOException {
        quickSort(arr, 0, number - 1);
    }

    static void quickSort(int[] arr, int start, int end) {
        if (start >= end) {
            return;  //원소가 1개인 경우
        }

        int pivot = start;  //pivot값은 첫번째 원소
        int i = start + 1;  //시작점 - 왼쪽부터 큰 값을 찾을 때 시작하는 인덱스
        int j = end;  //도착점 - 오른쪽부터 작은 값을 찾을 때 시작하는 인덱스
        int temp;  //수를 바꿀 때 사용하는 임시 변수

        while (i <= j) { // 엇갈릴 때까지 반복
            while (arr[i] <= arr[pivot]) { //pivot보다 더 큰 값을 만날 때까지
                i++;
            }
            while (arr[j] >= arr[pivot] && j > start) { //pivot보다 더 작은 값을 만날 때까지
                j--;
            }
            if (i > j) { //현재 엇갈린 상태면 pivot값과 교체
                temp = arr[j];
                arr[j] = arr[pivot];
                arr[pivot] = temp;
            } else { //엇갈리지 않았다면 i와 j를 교체
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        //분할된 왼쪽과 오른쪽 둘다 퀵 정렬 수행
        quickSort(arr, start, j - 1);
        quickSort(arr, j + 1, end);
    }
    }


    //내림차순일때 부호만 바꿔주면 된다.
    while (arr[i] >= arr[pivot]) { //pivot보다 더 큰 값을 만날 때까지
        i++;
    }
    while (arr[j] <= arr[pivot] && j > start) { //pivot보다 더 작은 값을 만날 때까지
        j--;
    }


[**목차로**](#목차)



-------

### merge sort(병합 정렬)

동일한 값의 원소가 입력에 따라 순서를 보장하는 안정 정렬 알고리즘이다.

- 병합 정렬 단계

1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.

2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.

3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.

![병합 정렬 전체적 흐름](/DataStructure+Algorithms/Algorithms/algorithm_images/merge-sort-concepts.png)

**- 병합 정렬 알고리즘 예시**

2개의 리스트의 값들을 처음부터 하나씩 비교하여 두 개의 리스트의 값 중에서 더 작은 값을 새로운 리스트(sorted)로 옮긴다.

![병합 정렬 알고리즘 흐름.](/DataStructure+Algorithms/Algorithms/algorithm_images/merge-sort.png)


    public class MergeSort {
        public void sort(int[] arr, int left, int right) {
            if (left == right) {
                return;
            }

            // 중간 인덱스
            int mid = (left + right) / 2;

            // 왼쪽 정렬
            sort(arr, left, mid);
            // 오른쪽 정렬
            sort(arr, mid + 1, right);

            // 배열 합치기
            merge(arr, left, mid, right);
        }

        public void merge(int[] arr, int left, int mid, int right) {
            int n1 = mid - left + 1; // 왼쪽 배열의 길이
            int n2 = right - mid; // 오른쪽 배열의 길이

            // 왼쪽 배열 오른쪽 배열
            int[] leftTemp = new int[n1];
            int[] rightTemp = new int[n2];

            // 왼쪽 배열 담기
            for (int i = 0; i < n1; i++) {
                leftTemp[i] = arr[left + i];
            }
            // 오른쪽 배열 담기
            for (int i = 0; i < n2; i++) {
                rightTemp[i] = arr[mid + 1 + i];
            }

            // 왼쪽 배열과 오른쪽 배열의 인덱스
            int i = 0, j = 0;
            // 원본 배열 arr의 시작 인덱스
            int k = left;

            // 원본 배열에 정렬
            while (i < n1 && j < n2) {
                if (leftTemp[i] <= rightTemp[j]) {
                    arr[k] = leftTemp[i];
                    i++;
                } else {
                    arr[k] = rightTemp[j];
                    j++;
                }
                k++;
            }

            // 남아 있는 요소 담기
            while (i < n1) {
                arr[k] = leftTemp[i];
                i++;
                k++;
            }

            while (j < n2) {
                arr[k] = rightTemp[j];
                j++;
                k++;
            }
        }
    }

    public class Main {
        public static void main(String[] args) {
            int[] array = {38, 27, 43, 3, 9, 82, 10};
            MergeSort mergeSort = new MergeSort();
            
            mergeSort.sort(array, 0, array.length - 1);

            for (int i : array) {
                System.out.print(i + " ");
            }
        }
    }

[**목차로**](#목차)

----
[힙정렬 정리](https://st-lab.tistory.com/225)

-----

### 참고 자료

[참고 사이트](https://velog.io/@suk13574/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-Binary-Search)

[참고 사이트](https://adjh54.tistory.com/187)

[버블 정렬 이미지](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)


[퀵 정렬 자바 코드](https://propercoding.tistory.com/195#google_vignette)

[병합 정렬 자바 코드](https://ittrue.tistory.com/564 )